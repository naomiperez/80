package expo.modules.updates.db.dao;

import android.database.Cursor;
import androidx.room.EntityDeletionOrUpdateAdapter;
import androidx.room.EntityInsertionAdapter;
import androidx.room.RoomDatabase;
import androidx.room.RoomSQLiteQuery;
import androidx.room.SharedSQLiteStatement;
import androidx.room.util.CursorUtil;
import androidx.room.util.DBUtil;
import androidx.room.util.StringUtil;
import androidx.sqlite.db.SupportSQLiteStatement;
import expo.modules.updates.db.Converters;
import expo.modules.updates.db.entity.AssetEntity;
import expo.modules.updates.db.entity.UpdateEntity;
import expo.modules.updates.db.enums.UpdateStatus;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.lang.SuppressWarnings;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

@SuppressWarnings({"unchecked", "deprecation"})
public final class UpdateDao_Impl extends UpdateDao {
  private final RoomDatabase __db;

  private final EntityInsertionAdapter __insertionAdapterOfUpdateEntity;

  private final EntityDeletionOrUpdateAdapter __deletionAdapterOfUpdateEntity;

  private final EntityDeletionOrUpdateAdapter __updateAdapterOfUpdateEntity;

  private final SharedSQLiteStatement __preparedStmtOf_keepUpdate;

  private final SharedSQLiteStatement __preparedStmtOf_markUpdateWithStatus;

  public UpdateDao_Impl(RoomDatabase __db) {
    this.__db = __db;
    this.__insertionAdapterOfUpdateEntity = new EntityInsertionAdapter<UpdateEntity>(__db) {
      @Override
      public String createQuery() {
        return "INSERT OR ABORT INTO `updates`(`id`,`scope_key`,`commit_time`,`runtime_version`,`launch_asset_id`,`metadata`,`status`,`keep`) VALUES (?,?,?,?,?,?,?,?)";
      }

      @Override
      public void bind(SupportSQLiteStatement stmt, UpdateEntity value) {
        final byte[] _tmp;
        _tmp = Converters.uuidToBytes(value.id);
        if (_tmp == null) {
          stmt.bindNull(1);
        } else {
          stmt.bindBlob(1, _tmp);
        }
        if (value.scopeKey == null) {
          stmt.bindNull(2);
        } else {
          stmt.bindString(2, value.scopeKey);
        }
        final Long _tmp_1;
        _tmp_1 = Converters.dateToLong(value.commitTime);
        if (_tmp_1 == null) {
          stmt.bindNull(3);
        } else {
          stmt.bindLong(3, _tmp_1);
        }
        if (value.runtimeVersion == null) {
          stmt.bindNull(4);
        } else {
          stmt.bindString(4, value.runtimeVersion);
        }
        if (value.launchAssetId == null) {
          stmt.bindNull(5);
        } else {
          stmt.bindLong(5, value.launchAssetId);
        }
        final String _tmp_2;
        _tmp_2 = Converters.jsonObjectToString(value.metadata);
        if (_tmp_2 == null) {
          stmt.bindNull(6);
        } else {
          stmt.bindString(6, _tmp_2);
        }
        final int _tmp_3;
        _tmp_3 = Converters.statusToInt(value.status);
        stmt.bindLong(7, _tmp_3);
        final int _tmp_4;
        _tmp_4 = value.keep ? 1 : 0;
        stmt.bindLong(8, _tmp_4);
      }
    };
    this.__deletionAdapterOfUpdateEntity = new EntityDeletionOrUpdateAdapter<UpdateEntity>(__db) {
      @Override
      public String createQuery() {
        return "DELETE FROM `updates` WHERE `id` = ?";
      }

      @Override
      public void bind(SupportSQLiteStatement stmt, UpdateEntity value) {
        final byte[] _tmp;
        _tmp = Converters.uuidToBytes(value.id);
        if (_tmp == null) {
          stmt.bindNull(1);
        } else {
          stmt.bindBlob(1, _tmp);
        }
      }
    };
    this.__updateAdapterOfUpdateEntity = new EntityDeletionOrUpdateAdapter<UpdateEntity>(__db) {
      @Override
      public String createQuery() {
        return "UPDATE OR ABORT `updates` SET `id` = ?,`scope_key` = ?,`commit_time` = ?,`runtime_version` = ?,`launch_asset_id` = ?,`metadata` = ?,`status` = ?,`keep` = ? WHERE `id` = ?";
      }

      @Override
      public void bind(SupportSQLiteStatement stmt, UpdateEntity value) {
        final byte[] _tmp;
        _tmp = Converters.uuidToBytes(value.id);
        if (_tmp == null) {
          stmt.bindNull(1);
        } else {
          stmt.bindBlob(1, _tmp);
        }
        if (value.scopeKey == null) {
          stmt.bindNull(2);
        } else {
          stmt.bindString(2, value.scopeKey);
        }
        final Long _tmp_1;
        _tmp_1 = Converters.dateToLong(value.commitTime);
        if (_tmp_1 == null) {
          stmt.bindNull(3);
        } else {
          stmt.bindLong(3, _tmp_1);
        }
        if (value.runtimeVersion == null) {
          stmt.bindNull(4);
        } else {
          stmt.bindString(4, value.runtimeVersion);
        }
        if (value.launchAssetId == null) {
          stmt.bindNull(5);
        } else {
          stmt.bindLong(5, value.launchAssetId);
        }
        final String _tmp_2;
        _tmp_2 = Converters.jsonObjectToString(value.metadata);
        if (_tmp_2 == null) {
          stmt.bindNull(6);
        } else {
          stmt.bindString(6, _tmp_2);
        }
        final int _tmp_3;
        _tmp_3 = Converters.statusToInt(value.status);
        stmt.bindLong(7, _tmp_3);
        final int _tmp_4;
        _tmp_4 = value.keep ? 1 : 0;
        stmt.bindLong(8, _tmp_4);
        final byte[] _tmp_5;
        _tmp_5 = Converters.uuidToBytes(value.id);
        if (_tmp_5 == null) {
          stmt.bindNull(9);
        } else {
          stmt.bindBlob(9, _tmp_5);
        }
      }
    };
    this.__preparedStmtOf_keepUpdate = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET keep = 1 WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_markUpdateWithStatus = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET status = ? WHERE id = ?;";
        return _query;
      }
    };
  }

  @Override
  public void insertUpdate(final UpdateEntity update) {
    __db.assertNotSuspendingTransaction();
    __db.beginTransaction();
    try {
      __insertionAdapterOfUpdateEntity.insert(update);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void deleteUpdates(final List<UpdateEntity> updates) {
    __db.assertNotSuspendingTransaction();
    __db.beginTransaction();
    try {
      __deletionAdapterOfUpdateEntity.handleMultiple(updates);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void _updateUpdate(final UpdateEntity update) {
    __db.assertNotSuspendingTransaction();
    __db.beginTransaction();
    try {
      __updateAdapterOfUpdateEntity.handle(update);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void markUpdateFinished(final UpdateEntity update,
      final boolean hasSkippedEmbeddedAssets) {
    __db.beginTransaction();
    try {
      UpdateDao_Impl.super.markUpdateFinished(update, hasSkippedEmbeddedAssets);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void _keepUpdate(final UUID id) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_keepUpdate.acquire();
    int _argIndex = 1;
    final byte[] _tmp;
    _tmp = Converters.uuidToBytes(id);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_keepUpdate.release(_stmt);
    }
  }

  @Override
  public void _markUpdateWithStatus(final UpdateStatus status, final UUID id) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_markUpdateWithStatus.acquire();
    int _argIndex = 1;
    final int _tmp;
    _tmp = Converters.statusToInt(status);
    _stmt.bindLong(_argIndex, _tmp);
    _argIndex = 2;
    final byte[] _tmp_1;
    _tmp_1 = Converters.uuidToBytes(id);
    if (_tmp_1 == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp_1);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_markUpdateWithStatus.release(_stmt);
    }
  }

  @Override
  public List<UpdateEntity> _loadUpdatesForProjectWithStatuses(final String scopeKey,
      final List<UpdateStatus> statuses) {
    StringBuilder _stringBuilder = StringUtil.newStringBuilder();
    _stringBuilder.append("SELECT * FROM updates WHERE scope_key = ");
    _stringBuilder.append("?");
    _stringBuilder.append(" AND status IN (");
    final int _inputSize = statuses.size();
    StringUtil.appendPlaceholders(_stringBuilder, _inputSize);
    _stringBuilder.append(");");
    final String _sql = _stringBuilder.toString();
    final int _argCount = 1 + _inputSize;
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, _argCount);
    int _argIndex = 1;
    if (scopeKey == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindString(_argIndex, scopeKey);
    }
    _argIndex = 2;
    for (UpdateStatus _item : statuses) {
      final int _tmp;
      _tmp = Converters.statusToInt(_item);
      _statement.bindLong(_argIndex, _tmp);
      _argIndex ++;
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfMetadata = CursorUtil.getColumnIndexOrThrow(_cursor, "metadata");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item_1;
        final UUID _tmpId;
        final byte[] _tmp_1;
        _tmp_1 = _cursor.getBlob(_cursorIndexOfId);
        _tmpId = Converters.bytesToUuid(_tmp_1);
        final String _tmpScopeKey;
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        final Date _tmpCommitTime;
        final Long _tmp_2;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = Converters.longToDate(_tmp_2);
        final String _tmpRuntimeVersion;
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        _item_1 = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey);
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item_1.launchAssetId = null;
        } else {
          _item_1.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        final String _tmp_3;
        _tmp_3 = _cursor.getString(_cursorIndexOfMetadata);
        _item_1.metadata = Converters.stringToJsonObject(_tmp_3);
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfStatus);
        _item_1.status = Converters.intToStatus(_tmp_4);
        final int _tmp_5;
        _tmp_5 = _cursor.getInt(_cursorIndexOfKeep);
        _item_1.keep = _tmp_5 != 0;
        _result.add(_item_1);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public List<UpdateEntity> _loadUpdatesWithId(final UUID id) {
    final String _sql = "SELECT * FROM updates WHERE id = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    final byte[] _tmp;
    _tmp = Converters.uuidToBytes(id);
    if (_tmp == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindBlob(_argIndex, _tmp);
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfMetadata = CursorUtil.getColumnIndexOrThrow(_cursor, "metadata");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item;
        final UUID _tmpId;
        final byte[] _tmp_1;
        _tmp_1 = _cursor.getBlob(_cursorIndexOfId);
        _tmpId = Converters.bytesToUuid(_tmp_1);
        final String _tmpScopeKey;
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        final Date _tmpCommitTime;
        final Long _tmp_2;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = Converters.longToDate(_tmp_2);
        final String _tmpRuntimeVersion;
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        _item = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey);
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item.launchAssetId = null;
        } else {
          _item.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        final String _tmp_3;
        _tmp_3 = _cursor.getString(_cursorIndexOfMetadata);
        _item.metadata = Converters.stringToJsonObject(_tmp_3);
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfStatus);
        _item.status = Converters.intToStatus(_tmp_4);
        final int _tmp_5;
        _tmp_5 = _cursor.getInt(_cursorIndexOfKeep);
        _item.keep = _tmp_5 != 0;
        _result.add(_item);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public AssetEntity _loadLaunchAsset(final UUID id) {
    final String _sql = "SELECT assets.* FROM assets INNER JOIN updates ON updates.launch_asset_id = assets.id WHERE updates.id = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    final byte[] _tmp;
    _tmp = Converters.uuidToBytes(id);
    if (_tmp == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindBlob(_argIndex, _tmp);
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfUrl = CursorUtil.getColumnIndexOrThrow(_cursor, "url");
      final int _cursorIndexOfKey = CursorUtil.getColumnIndexOrThrow(_cursor, "key");
      final int _cursorIndexOfHeaders = CursorUtil.getColumnIndexOrThrow(_cursor, "headers");
      final int _cursorIndexOfType = CursorUtil.getColumnIndexOrThrow(_cursor, "type");
      final int _cursorIndexOfMetadata = CursorUtil.getColumnIndexOrThrow(_cursor, "metadata");
      final int _cursorIndexOfDownloadTime = CursorUtil.getColumnIndexOrThrow(_cursor, "download_time");
      final int _cursorIndexOfRelativePath = CursorUtil.getColumnIndexOrThrow(_cursor, "relative_path");
      final int _cursorIndexOfHash = CursorUtil.getColumnIndexOrThrow(_cursor, "hash");
      final int _cursorIndexOfHashType = CursorUtil.getColumnIndexOrThrow(_cursor, "hash_type");
      final int _cursorIndexOfMarkedForDeletion = CursorUtil.getColumnIndexOrThrow(_cursor, "marked_for_deletion");
      final AssetEntity _result;
      if(_cursor.moveToFirst()) {
        final String _tmpKey;
        _tmpKey = _cursor.getString(_cursorIndexOfKey);
        final String _tmpType;
        _tmpType = _cursor.getString(_cursorIndexOfType);
        _result = new AssetEntity(_tmpKey,_tmpType);
        _result.id = _cursor.getLong(_cursorIndexOfId);
        final String _tmp_1;
        _tmp_1 = _cursor.getString(_cursorIndexOfUrl);
        _result.url = Converters.stringToUri(_tmp_1);
        final String _tmp_2;
        _tmp_2 = _cursor.getString(_cursorIndexOfHeaders);
        _result.headers = Converters.stringToJsonObject(_tmp_2);
        final String _tmp_3;
        _tmp_3 = _cursor.getString(_cursorIndexOfMetadata);
        _result.metadata = Converters.stringToJsonObject(_tmp_3);
        final Long _tmp_4;
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_4 = null;
        } else {
          _tmp_4 = _cursor.getLong(_cursorIndexOfDownloadTime);
        }
        _result.downloadTime = Converters.longToDate(_tmp_4);
        _result.relativePath = _cursor.getString(_cursorIndexOfRelativePath);
        _result.hash = _cursor.getBlob(_cursorIndexOfHash);
        final int _tmp_5;
        _tmp_5 = _cursor.getInt(_cursorIndexOfHashType);
        _result.hashType = Converters.intToHashType(_tmp_5);
        final int _tmp_6;
        _tmp_6 = _cursor.getInt(_cursorIndexOfMarkedForDeletion);
        _result.markedForDeletion = _tmp_6 != 0;
      } else {
        _result = null;
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public List<UpdateEntity> loadAllUpdatesForScope(final String scopeKey) {
    final String _sql = "SELECT * FROM updates WHERE scope_key = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    if (scopeKey == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindString(_argIndex, scopeKey);
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfMetadata = CursorUtil.getColumnIndexOrThrow(_cursor, "metadata");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item;
        final UUID _tmpId;
        final byte[] _tmp;
        _tmp = _cursor.getBlob(_cursorIndexOfId);
        _tmpId = Converters.bytesToUuid(_tmp);
        final String _tmpScopeKey;
        _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        final Date _tmpCommitTime;
        final Long _tmp_1;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = Converters.longToDate(_tmp_1);
        final String _tmpRuntimeVersion;
        _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        _item = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey);
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _item.launchAssetId = null;
        } else {
          _item.launchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        final String _tmp_2;
        _tmp_2 = _cursor.getString(_cursorIndexOfMetadata);
        _item.metadata = Converters.stringToJsonObject(_tmp_2);
        final int _tmp_3;
        _tmp_3 = _cursor.getInt(_cursorIndexOfStatus);
        _item.status = Converters.intToStatus(_tmp_3);
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfKeep);
        _item.keep = _tmp_4 != 0;
        _result.add(_item);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }
}

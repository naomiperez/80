{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from \"./utils/serialize\";\nimport { DOCUMENT_ID } from \"./FirestoreFieldPath\";\nvar OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN'\n};\nvar INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true\n};\nvar DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n\nvar FirestoreQueryModifiers = function () {\n  function FirestoreQueryModifiers() {\n    _classCallCheck(this, FirestoreQueryModifiers);\n\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _createClass(FirestoreQueryModifiers, [{\n    key: \"_copy\",\n    value: function _copy() {\n      var newInstance = new FirestoreQueryModifiers();\n      newInstance._limit = this._limit;\n      newInstance._limitToLast = this._limitToLast;\n      newInstance._filters = _toConsumableArray(this._filters);\n      newInstance._orders = _toConsumableArray(this._orders);\n      newInstance._type = this._type;\n      newInstance._startAt = this._startAt;\n      newInstance._startAfter = this._startAfter;\n      newInstance._endAt = this._endAt;\n      newInstance._endBefore = this._endBefore;\n      return newInstance;\n    }\n  }, {\n    key: \"filters\",\n    get: function get() {\n      return this._filters.map(function (f) {\n        return _objectSpread(_objectSpread({}, f), {}, {\n          fieldPath: f.fieldPath._toArray()\n        });\n      });\n    }\n  }, {\n    key: \"orders\",\n    get: function get() {\n      return this._orders;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var options = {};\n\n      if (this._limit) {\n        options.limit = this._limit;\n      }\n\n      if (this._limitToLast) {\n        options.limitToLast = this._limitToLast;\n      }\n\n      if (this._startAt) {\n        options.startAt = this._startAt;\n      }\n\n      if (this._startAfter) {\n        options.startAfter = this._startAfter;\n      }\n\n      if (this._endAt) {\n        options.endAt = this._endAt;\n      }\n\n      if (this._endBefore) {\n        options.endBefore = this._endBefore;\n      }\n\n      return options;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"setFieldsCursor\",\n    value: function setFieldsCursor(cursor, fields) {\n      this[\"_\" + cursor] = buildNativeArray(fields);\n      return this;\n    }\n  }, {\n    key: \"hasStart\",\n    value: function hasStart() {\n      return !!(this._startAt || this._startAfter);\n    }\n  }, {\n    key: \"hasEnd\",\n    value: function hasEnd() {\n      return !!(this._endAt || this._endBefore);\n    }\n  }, {\n    key: \"asCollectionGroupQuery\",\n    value: function asCollectionGroupQuery() {\n      this._type = 'collectionGroup';\n      return this;\n    }\n  }, {\n    key: \"isCollectionGroupQuery\",\n    value: function isCollectionGroupQuery() {\n      return this._type === 'collectionGroup';\n    }\n  }, {\n    key: \"isValidLimit\",\n    value: function isValidLimit(limit) {\n      return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      this._limitToLast = undefined;\n      this._limit = _limit;\n      return this;\n    }\n  }, {\n    key: \"isValidLimitToLast\",\n    value: function isValidLimitToLast(limit) {\n      return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"validatelimitToLast\",\n    value: function validatelimitToLast() {\n      if (this._limitToLast) {\n        if (!this._orders.length) {\n          throw new Error('firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause');\n        }\n      }\n    }\n  }, {\n    key: \"limitToLast\",\n    value: function limitToLast(_limitToLast) {\n      this._limit = undefined;\n      this._limitToLast = _limitToLast;\n      return this;\n    }\n  }, {\n    key: \"isValidOperator\",\n    value: function isValidOperator(operator) {\n      return !!OPERATORS[operator];\n    }\n  }, {\n    key: \"isEqualOperator\",\n    value: function isEqualOperator(operator) {\n      return OPERATORS[operator] === 'EQUAL';\n    }\n  }, {\n    key: \"isInOperator\",\n    value: function isInOperator(operator) {\n      return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' || OPERATORS[operator] === 'NOT_IN';\n    }\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      var filter = {\n        fieldPath: fieldPath,\n        operator: OPERATORS[opStr],\n        value: generateNativeData(value, true)\n      };\n      this._filters = this._filters.concat(filter);\n      return this;\n    }\n  }, {\n    key: \"validateWhere\",\n    value: function validateWhere() {\n      var hasInequality;\n      var hasNotEqual;\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        if (!INEQUALITY[filter.operator]) {\n          continue;\n        }\n\n        if (filter.operator === OPERATORS['!=']) {\n          if (hasNotEqual) {\n            throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n          }\n\n          hasNotEqual = true;\n        }\n\n        if (!hasInequality) {\n          hasInequality = filter;\n          continue;\n        }\n\n        if (INEQUALITY[filter.operator] && hasInequality) {\n          if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n            throw new Error(\"Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '\" + hasInequality.fieldPath._toPath() + \"' and '\" + filter.fieldPath._toPath() + \"'\");\n          }\n        }\n      }\n\n      var hasArrayContains;\n      var hasArrayContainsAny;\n      var hasIn;\n      var hasNotIn;\n\n      for (var _i = 0; _i < this._filters.length; _i++) {\n        var _filter = this._filters[_i];\n\n        if (_filter.operator === OPERATORS['array-contains']) {\n          if (hasArrayContains) {\n            throw new Error('Invalid query. Queries only support a single array-contains filter.');\n          }\n\n          hasArrayContains = true;\n        }\n\n        if (_filter.operator === OPERATORS['array-contains-any']) {\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n          }\n\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\");\n          }\n\n          if (hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\");\n          }\n\n          hasArrayContainsAny = true;\n        }\n\n        if (_filter.operator === OPERATORS.in) {\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n          }\n\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\");\n          }\n\n          if (hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n          }\n\n          hasIn = true;\n        }\n\n        if (_filter.operator === OPERATORS['not-in']) {\n          if (hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n          }\n\n          if (hasNotEqual) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\");\n          }\n\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n          }\n\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\");\n          }\n\n          hasNotIn = true;\n        }\n      }\n    }\n  }, {\n    key: \"isValidDirection\",\n    value: function isValidDirection(directionStr) {\n      return !!DIRECTIONS[directionStr.toLowerCase()];\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      var order = {\n        fieldPath: fieldPath._toPath(),\n        direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n      };\n      this._orders = this._orders.concat(order);\n      return this;\n    }\n  }, {\n    key: \"validateOrderBy\",\n    value: function validateOrderBy() {\n      if (this._orders.length > 1) {\n        var orders = this._orders.map(function ($) {\n          return $.fieldPath;\n        });\n\n        var set = new Set(orders);\n\n        if (set.size !== orders.length) {\n          throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n        }\n      }\n\n      if (this._filters.length === 0) {\n        return;\n      }\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        var filterFieldPath = filter.fieldPath._toPath();\n\n        for (var k = 0; k < this._orders.length; k++) {\n          var order = this._orders[k];\n          var orderFieldPath = order.fieldPath;\n\n          if (filter.operator === OPERATORS['==']) {\n            if (filterFieldPath === orderFieldPath) {\n              throw new Error(\"Invalid query. Query.orderBy() parameter: \" + orderFieldPath + \" cannot be the same as your Query.where() fieldPath parameter: \" + filterFieldPath);\n            }\n          }\n\n          if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n            throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n          }\n\n          if (INEQUALITY[filter.operator]) {\n            if (filterFieldPath !== this._orders[0].fieldPath) {\n              throw new Error(\"Invalid query. Initial Query.orderBy() parameter: \" + orderFieldPath + \" has to be the same as the Query.where() fieldPath parameter(s): \" + filterFieldPath + \" when an inequality operator is invoked \");\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return FirestoreQueryModifiers;\n}();\n\nexport { FirestoreQueryModifiers as default };","map":{"version":3,"sources":["/Users/naomiperez/Documents/GitHub/80/client/80hd/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"names":["isNumber","buildNativeArray","generateNativeData","DOCUMENT_ID","OPERATORS","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","NOT_EQUAL","DIRECTIONS","asc","desc","FirestoreQueryModifiers","_limit","undefined","_limitToLast","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","newInstance","map","f","fieldPath","_toArray","options","limit","limitToLast","startAt","startAfter","endAt","endBefore","cursor","fields","Math","floor","length","Error","operator","opStr","value","filter","concat","hasInequality","hasNotEqual","i","_toPath","hasArrayContains","hasArrayContainsAny","hasIn","hasNotIn","directionStr","toLowerCase","order","direction","orders","$","set","Set","size","filterFieldPath","k","orderFieldPath"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nimport { DOCUMENT_ID } from './FirestoreFieldPath';\n\nconst OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({ ...f, fieldPath: f.fieldPath._toArray() }));\n  }\n\n  get orders() {\n    return this._orders;\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error(\n          'firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause',\n        );\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isInOperator(operator) {\n    return (\n      OPERATORS[operator] === 'IN' ||\n      OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' ||\n      OPERATORS[operator] === 'NOT_IN'\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    let hasInequality;\n    let hasNotEqual;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      if (filter.operator === OPERATORS['!=']) {\n        if (hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        }\n        //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n        hasNotEqual = true;\n      }\n\n      // Set the first inequality\n      if (!hasInequality) {\n        hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && hasInequality) {\n        if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    let hasArrayContains;\n    let hasArrayContainsAny;\n    let hasIn;\n    let hasNotIn;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\",\n          );\n        }\n\n        if (hasNotIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\",\n          );\n        }\n\n        hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n\n        hasIn = true;\n      }\n\n      if (filter.operator === OPERATORS['not-in']) {\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n\n        if (hasNotEqual) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        hasNotIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath._toPath(),\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath);\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (this._filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreTransaction from \"./FirestoreTransaction\";\nvar transactionId = 0;\n\nvar generateTransactionId = function generateTransactionId() {\n  return transactionId++;\n};\n\nvar FirestoreTransactionHandler = function () {\n  function FirestoreTransactionHandler(firestore) {\n    _classCallCheck(this, FirestoreTransactionHandler);\n\n    this._firestore = firestore;\n    this._pending = {};\n\n    this._firestore.emitter.addListener(this._firestore.eventNameForApp('firestore_transaction_event'), this._onTransactionEvent.bind(this));\n  }\n\n  _createClass(FirestoreTransactionHandler, [{\n    key: \"_onTransactionEvent\",\n    value: function _onTransactionEvent(event) {\n      switch (event.body.type) {\n        case 'update':\n          this._handleUpdate(event);\n\n          break;\n\n        case 'error':\n          this._handleError(event);\n\n          break;\n\n        case 'complete':\n          this._handleComplete(event);\n\n          break;\n      }\n    }\n  }, {\n    key: \"_handleUpdate\",\n    value: function _handleUpdate(event) {\n      var id, _this$_pending$id, meta, transaction, updateFunction, reject, finalError, updateFailed, pendingResult, possiblePromise;\n\n      return _regeneratorRuntime.async(function _handleUpdate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = event.listenerId;\n\n              if (this._pending[id]) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\", this._remove(id));\n\n            case 3:\n              _this$_pending$id = this._pending[id], meta = _this$_pending$id.meta, transaction = _this$_pending$id.transaction;\n              updateFunction = meta.updateFunction, reject = meta.reject;\n\n              transaction._prepare();\n\n              _context.prev = 6;\n              possiblePromise = updateFunction(transaction);\n\n              if (!(!possiblePromise || !possiblePromise.then)) {\n                _context.next = 10;\n                break;\n              }\n\n              throw new Error(\"firebase.firestore().runTransaction(*) 'updateFunction' must return a Promise.\");\n\n            case 10:\n              _context.next = 12;\n              return _regeneratorRuntime.awrap(possiblePromise);\n\n            case 12:\n              pendingResult = _context.sent;\n              _context.next = 19;\n              break;\n\n            case 15:\n              _context.prev = 15;\n              _context.t0 = _context[\"catch\"](6);\n              updateFailed = true;\n              finalError = _context.t0;\n\n            case 19:\n              if (!(updateFailed || finalError)) {\n                _context.next = 21;\n                break;\n              }\n\n              return _context.abrupt(\"return\", reject(finalError));\n\n            case 21:\n              transaction._pendingResult = pendingResult;\n              return _context.abrupt(\"return\", this._firestore.native.transactionApplyBuffer(id, transaction._commandBuffer));\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[6, 15]], Promise);\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(event) {\n      var id = event.listenerId,\n          body = event.body;\n      var error = body.error;\n\n      if (!this._pending[id]) {\n        return;\n      }\n\n      var meta = this._pending[id].meta;\n\n      if (meta && error) {\n        var errorAndStack = NativeError.fromEvent(error, 'firestore', meta.stack);\n        meta.reject(errorAndStack);\n      }\n    }\n  }, {\n    key: \"_handleComplete\",\n    value: function _handleComplete(event) {\n      var id = event.listenerId;\n\n      if (!this._pending[id]) {\n        return;\n      }\n\n      var _this$_pending$id2 = this._pending[id],\n          meta = _this$_pending$id2.meta,\n          transaction = _this$_pending$id2.transaction;\n\n      if (meta) {\n        meta.resolve(transaction._pendingResult);\n      }\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(updateFunction) {\n      var _this = this;\n\n      var id = generateTransactionId();\n      var meta = {\n        id: id,\n        updateFunction: updateFunction,\n        stack: new Error().stack.split('\\n').slice(2).join('\\n')\n      };\n      this._pending[id] = {\n        meta: meta,\n        transaction: new FirestoreTransaction(this._firestore, meta)\n      };\n      return new Promise(function (resolve, reject) {\n        _this._firestore.native.transactionBegin(id);\n\n        meta.resolve = function (result) {\n          _this._remove(id);\n\n          resolve(result);\n        };\n\n        meta.reject = function (error) {\n          _this._remove(id);\n\n          reject(error);\n        };\n      });\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(id) {\n      this._firestore.native.transactionDispose(id);\n\n      delete this._pending[id];\n    }\n  }]);\n\n  return FirestoreTransactionHandler;\n}();\n\nexport { FirestoreTransactionHandler as default };","map":{"version":3,"sources":["/Users/naomiperez/Documents/GitHub/80/client/80hd/node_modules/@react-native-firebase/firestore/lib/FirestoreTransactionHandler.js"],"names":["NativeError","FirestoreTransaction","transactionId","generateTransactionId","FirestoreTransactionHandler","firestore","_firestore","_pending","emitter","addListener","eventNameForApp","_onTransactionEvent","bind","event","body","type","_handleUpdate","_handleError","_handleComplete","id","listenerId","_remove","meta","transaction","updateFunction","reject","_prepare","possiblePromise","then","Error","pendingResult","updateFailed","finalError","_pendingResult","native","transactionApplyBuffer","_commandBuffer","error","errorAndStack","fromEvent","stack","resolve","split","slice","join","Promise","transactionBegin","result","transactionDispose"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreTransaction from './FirestoreTransaction';\n\nlet transactionId = 0;\n\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\nconst generateTransactionId = () => transactionId++;\n\nexport default class FirestoreTransactionHandler {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._pending = {};\n    this._firestore.emitter.addListener(\n      this._firestore.eventNameForApp('firestore_transaction_event'),\n      this._onTransactionEvent.bind(this),\n    );\n  }\n\n  _onTransactionEvent(event) {\n    switch (event.body.type) {\n      case 'update':\n        this._handleUpdate(event);\n        break;\n      case 'error':\n        this._handleError(event);\n        break;\n      case 'complete':\n        this._handleComplete(event);\n        break;\n    }\n  }\n\n  async _handleUpdate(event) {\n    const { listenerId: id } = event;\n\n    // abort if no longer exists js side\n    if (!this._pending[id]) {\n      return this._remove(id);\n    }\n\n    const { meta, transaction } = this._pending[id];\n    const { updateFunction, reject } = meta;\n\n    // clear any saved state from previous transaction runs\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult;\n\n    try {\n      const possiblePromise = updateFunction(transaction);\n\n      // validate user has returned a promise in their update function\n      if (!possiblePromise || !possiblePromise.then) {\n        throw new Error(\n          \"firebase.firestore().runTransaction(*) 'updateFunction' must return a Promise.\",\n        );\n      }\n\n      pendingResult = await possiblePromise;\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    }\n\n    // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n    if (updateFailed || finalError) {\n      return reject(finalError);\n    }\n\n    // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n    transaction._pendingResult = pendingResult;\n\n    // send the buffered update/set/delete commands for native to process\n    return this._firestore.native.transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n\n  /**\n   * Reject the promise with a native error event\n   *\n   * @param event\n   * @private\n   */\n  _handleError(event) {\n    const { listenerId: id, body } = event;\n    const { error } = body;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const { meta } = this._pending[id];\n\n    if (meta && error) {\n      const errorAndStack = NativeError.fromEvent(error, 'firestore', meta.stack);\n      meta.reject(errorAndStack);\n    }\n  }\n\n  /**\n   * Once the transaction has completed on native, resolve the promise with any\n   * pending results\n   *\n   * @param event\n   * @private\n   */\n  _handleComplete(event) {\n    const { listenerId: id } = event;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const { meta, transaction } = this._pending[id];\n    if (meta) {\n      meta.resolve(transaction._pendingResult);\n    }\n  }\n\n  /**\n   * Internally adds a transaction execution function to the queue\n   *\n   * @param updateFunction\n   * @returns {Promise<any>}\n   * @private\n   */\n  _add(updateFunction) {\n    const id = generateTransactionId();\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n'),\n    };\n\n    this._pending[id] = {\n      meta,\n      transaction: new FirestoreTransaction(this._firestore, meta),\n    };\n\n    return new Promise((resolve, reject) => {\n      this._firestore.native.transactionBegin(id);\n\n      meta.resolve = result => {\n        this._remove(id);\n        resolve(result);\n      };\n\n      meta.reject = error => {\n        this._remove(id);\n        reject(error);\n      };\n    });\n  }\n\n  /**\n   * Internally removes the transaction once it has resolved\n   * or rejected\n   *\n   * @param id\n   * @private\n   */\n  _remove(id) {\n    this._firestore.native.transactionDispose(id);\n    delete this._pending[id];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}